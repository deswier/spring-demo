# Аннотация @Autowired

`@Autowired` - это аннотация в Spring Framework, которая используется для автоматического внедрения зависимостей (DI).

**Ключевые моменты:**

*   **Цель:** Автоматизация связывания между компонентами Spring.
*   **Места использования:** Может применяться к конструкторам, полям и методам (обычно сеттерам).
*   **Рекомендация:** Внедрение через конструктор является предпочтительным подходом, поскольку оно обеспечивает инициализацию необходимых зависимостей при создании объекта и упрощает тестирование.
*   **Начиная со Spring 4.3:** Если в классе есть только один конструктор, аннотацию `@Autowired` над ним можно опустить.

# Типы внедрений

Есть три основных способа внедрить ваши зависимости в класс: через конструктор, сеттер и поле.

## Внедрение через конструктор (Constructor Injection)

Это наиболее рекомендуемый способ внедрения зависимостей. Зависимости передаются как параметры конструктора.

```java
private final DependencyA dependencyA;
private final DependencyB dependencyB;

@Autowired
public DI(DependencyA dependencyA, DependencyB dependencyB) {
    this.dependencyA = dependencyA;
    this.dependencyB = dependencyB;
}
```

**Преимущества:**
*   **Надежность:** Гарантирует, что объект будет создан с полностью инициализированными зависимостями. Поля могут быть объявлены как `final`, что обеспечивает их неизменяемость.
*   **Прозрачность:** Все необходимые зависимости явно перечислены в конструкторе, что делает код более читаемым и понятным.
*   **Тестируемость:** Легко создавать экземпляры объектов для модульного тестирования, передавая моки или стабы в конструктор без необходимости использования Spring-контекста.

**Недостатки:**
*   **Многословие:** Может привести к большим конструкторам, если у класса много зависимостей. Однако это часто является сигналом того, что класс нарушает принцип единственной ответственности (Single Responsibility Principle) и его следует рефакторить.
*   **Не подходит для циклических зависимостей:** Spring не сможет разрешить циклические зависимости между бинами при внедрении через конструктор.

## Внедрение через сеттер (Setter Injection)

Зависимости внедряются через вызов `set`-методов.

```java
private DependencyA dependencyA;
private DependencyB dependencyB;

@Autowired
public void setDependencyA(DependencyA dependencyA) {
    this.dependencyA = dependencyA;
}

@Autowired
public void setDependencyB(DependencyB dependencyB) {
    this.dependencyB = dependencyB;
}
```

**Преимущества:**
*   **Гибкость:** Позволяет внедрять необязательные зависимости. Если пометить `@Autowired(required = false)`, Spring не будет выдавать ошибку, если бин не найден.
*   **Переконфигурация:** Позволяет изменять зависимости во время выполнения (например, через JMX).

**Недостатки:**
*   **Возможность неполной инициализации:** Объект может быть создан, но его зависимости могут быть не установлены, что может привести к `NullPointerException`.
*   **Многословность:** Требует создания сеттеров для каждой зависимости.

## Внедрение через поле (Field Injection)

Зависимости внедряются напрямую в поля класса.

```java
@Autowired
private DependencyA dependencyA;
@Autowired
private DependencyB dependencyB;
```

**Преимущества:**
*   **Краткость:** Требует минимального количества кода.

**Недостатки:**
*   **Скрытие зависимостей:** Зависимости класса не очевидны из его публичного API (конструкторов или методов).
*   **Сложность тестирования:** Очень трудно тестировать такой класс в изоляции (юнит-тесты), так как для установки зависимостей требуется использовать рефлексию.
*   **Нарушение принципа единственной ответственности:** Легкость добавления новых зависимостей может привести к созданию классов с большим количеством обязанностей.
*   **Невозможность использования `final`:** Нельзя объявить поля как `final`, что делает объект изменяемым.
*   **Риск `NullPointerException`:** Если вы попытаетесь создать экземпляр класса вручную (через `new`), его поля, помеченные `@Autowired`, останутся `null`.

### Итог
Внедрение через конструктор является предпочтительным методом для обязательных зависимостей, в то время как внедрение через сеттер можно использовать для необязательных. Внедрение через поле, несмотря на свою краткость, не рекомендуется для использования в большинстве случаев из-за его существенных недостатков.

### Связанные статьи
* [qualifier.md](qualifier.md)
